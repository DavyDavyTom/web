[toc]

# C语言重点知识

## 第一章 基本概念 C程序 VS使用

1. 程序为解决特定问题而用计算机语言编写的有序指令序列的集合

2. 语言的发展：机器语言(二进制的01) --> 汇编语言(低级语言) --> 高级语言  

3. C语言的标准 ： C语言的发展史也是标准的发展史  VS2012默认使用C99标准

4. C语言的实现： 通过实现可以自动检查指令是否符合标准？

5. 一个C语言程序有且只能有一个main函数，是exe文件中 c 文件的起始位置

6. 编译器：人和计算机之间的翻译，把高级语言写成的源程序翻译成计算机能懂的机器语言。

7. **程序的执行过程**  

   编辑Edit： 源文件.c **标准里定义的源字符集扩充基本字符集中有汉语和日语等**              头文 件 .h                             

   编译Compile： **翻译（对于C语言来说是编译）**   ***检查语法规范*** （头文件不会被翻译）.      .obj

   链接Link：        连接所需的文件，关联头文件.h等  .exe

   运行Run：         

   调试（debug）也是一个环节

8. **解释和编译的区别**。

9. C语言的实现：通过实现可以自动检查。

10. 单词是组成源文件的最小单位。包括：

   关键词（37个）

   标示符    

   字面值   

   操作符   各种运算符，还有sizeof等

   字符串     

   分隔符     [] * , : = # {}（）；。等   (各种单词之间有重复的)

   *预处理单词*

   *注释*

   *头文件名*

11. 两种正确写法？

12. 预处理指令#include 将指定的头文件内容放到预处理指令的所在位置。

13. 注释 缩进 空格 良好的编程风格。

## 第二章 数据类型 常量与字面值  输入与输出

###2.1数据类型

1.   sqrt 函数求根在 math.h 文件中。

2. 问题求解的大致过程： 问题抽象为算法  算法映射为程序 程序编译连接为可执行文件 最后解决问题。

3. **算法的五大特征**：有穷性、确切性、可行性、一个算法有**零个**或多个输入、一个算法有一个或多个输出。

4. <limits.h> 和 <float.h>

5. 存储空间大小单位：b B KB MB GB TB

6. 内存以字节编址

7. 八进制数前加0  十六进制前加0X

8. 可以给内存中一块连续的空间，起一个名字，通过这个名字来操作它，这个名字叫变量名，也叫标识符。

9. sizeof可以得到**变量**或**数据类型**的字节数。

10. **变量名**

    变量名由数字、字母、下划线组成

    数字不能打头

    不能使用C语言的关键字

    区分大小写

11. 变量先定义后使用   先赋值后参与运算

12. 变量值又称为字面值

13. 数据类型字节大小，数值范围
  
  - 整型 int
  
    - short int    2           
    - int              4
    - long           4
    - long long  8
    - unsigned short                    2
    - unsigned int                         4
    - unsigned long                      4
    - unsigned long long             8
  
  - 浮点型( 实型)
  
    - float                  4
    - double              8
    - long double     8
  
  - 字符型  
  
    - char   1
  
14. 数据类型储存方式

    - 无符号整型

      直接按二进制方式进行存储，数值范围计算方式  **0 - 2^(位数) - 1**

      例如：unsigned  int类型  共32位， 最大值为2^32 - 1              **易错！！**

      ​           二进制数 10的大小为 2^(位数 - 1) = 2

    - 有符号整型

      用补码的方式进行存储，补码中**最小值用1000 0000表示 大小为 -2^(位数 - 1)， 最大值 0000 0001大小  2^(位数) - 1 **

      

      ![img](https://pic2.zhimg.com/80/v2-f626697aa9768d43974657c7f06b3e5e_720w.jpg)

    - 浮点型

      -  IEEE-754标准（1985年提出）

      - 例子： float 存储 4.25（十进制）

        

      ​        0  10000001  00010000000000000000000

         

      ​        |              |                                |

      ​      符号(1)   阶码 (8)                  尾码(23)

      ​    

      ​         1、将十进制小数转换成二进制

      ​           4.25（十进制） -> 100.01（二进制）

      ​         2、将二进制小数转成科学计数法形式

      ​           100.01 ->  1.0001 * **2** ^ 2
      
      ​         3、求阶码，阶码 = 2 + 127 = 129
      
      ​         4、求尾码，尾码 = 0001
      
      - 符号位：正数存0 负数存1
      - 阶码：阶码 = 2的次幂 + 127（**移码 ** 补码的相反数）？？？？？？？？？？
      - 尾码：小数点后面的就是尾码
      - <img src="D:\常用文件\软件工程\C\img\浮点数存储.jpg" alt="浮点数存储" style="zoom:20%;" />
      - **不能比较大小**
      - 只有6到7位**有限范围**可以做到**尽量精确**的**近似存储**
      
    - 字符型
    
      使用单引号
    
      实际上**存放的是字母的ASCII码**，大小一个字节，用补码存放
    
      **[48 , 57] 数字0到9**
    
      **[65,90] 大写字母A到Z**
    
      **[97,122] 小写字母a到z **和大写字母相差32
    
      用 %d 输出可以查出字符的ASCII码
    
      **以 \ 开头的特殊字符成为转义字符**
    
15. 减法中通过补码形式用加法代替减法，计算机中的负数都是用补码存储的，所以用转换，任意数相加减就是相应的内存中的值进行相加，所以只需要加法器。

    <img src="\img\减法实现.jpg" alt="IMG_20200625_154116" style="zoom:20%;" />

16. 整型数值溢出：最大值+1变为最小值，最小值-1变为最大值

17. 实型数据无法精确表示所有数据类型，每种实型数据都有自己的精度和有效范围。

    有效数字取6位 

    ```c
    #include <math.h>
    fabs(a-b) <= 1e-6
    ```

    

###2.2字面值和常量  

1. 变量声明中包含const可以声明常量。

2. 字面值类型

    - 整型
      - 100
      - 0347
      - 0x1256B
      - 一般默认整型常量为**int型**
      - 后缀 
        - 长整型字面值    123L   123l
        - 无符号整型字面值    123U  123u
        - 无符号长整型字面值  123UL  123ul
        - long  long  型字面值   123LL  123ll
      
    - 浮点型
      - 1.0
      - 3e2    表示3*10^2       即300
      - 1.0E-3  1.0*10^（-2）即0.001
      - .313131           省略0.  表示0.313131 
      - 一般默认为**double型**
      - 后缀
        - 单精度浮点型字面值    1.0F   1.0f
        - 长双精度浮点型字面值   1.0**L**   1.0**l**

    - 字符型  用单引号括起来的**单个普通字符**或**转义字符**。

      - 执行字符集：‘A’ (对应ASCII码整数65)，‘b’，‘#’

      - 宽字符集

      - 转义字符：用来表示很难输入的字符，同样站一个字节
      
        - 换行  \n
      - 水平制表符  \t
        - 响铃             \a
      - 反斜线        \\\
        - 单引号         \\'
      - 双引号         \\""
        - 数字转义字符
      - **3位8进制数代表字符**       \ddd     例如‘\101’  表示 ‘A’  
          - **2位16进制代表字符**         \\ **x**hh     例如‘\41’   表示 ‘ A ’      x区分大小写
      - **特别：**要输出%需要使用  两个百分号 %%
      
    - 字符串型  有一对**双引号**括起来的字符序列，以‘ \0 ’ 结束
    
      - “”  表示空串，只包含‘\0’
      - ‘ a ’   和 “  a  ”
        -  **字符串长度**分别为 1   1
        - **字符个数**分别为    1    2
    
3.   常量分类

    - 字面常量（直接常量）
    
    - 符号常量
    
      - 明示常量（宏常量）
    
        ```c
        #define TEXRATE  123  //没有 =  ，通常用大写字母表示名称
        #define num 1 + 2     //边际效应
        #define num "1 + 2"     //定义字符串
        ```
    
        **编译**时会将程序中的TEXRATE替换为123，不占用类型，不会进行安全检查，存在边际效应。
    
        在头文件limits.h 和 float.h 中有供实现使用的明示常量如 INT_MAX。
    
      - const常量
    
        是一种类型，会在编译时进行严格的安全检查，防止被更改。
    
4.   计算机存储的字符型字面值其实是整数int???????????????????

    区分与字符类型，字符类型大小为1字节，字符字面值大小为4字节。 

    ```c
    	printf("%d \n",sizeof 'a'); //  4
    ```


5. ```c
       char a = '1' ;    //char 是数据类型    a是标示符、变量名    ‘1’是数据对象
                         //‘1’  是一个字符型字面值
  ```

6. **两个字符串字面值相邻时，会自动拼接到一起**

  "ab""cd"  :   会变为"abcd"，字符长度是4，字符个数是5 。

###2.3输入与输出

#### 2.3.1 scanf和printf

1. 格式化输出函数 printf

    - 一般形式：printf（字符串字面值，参数1，参数2，……参数n）；

      - 注：返回值大于0表示输出的字符个数，小于零表示输出错误。

    - 转换说明的一般形式：

      %[标志字符] [最小宽度说明] [精度说明] [长度修正说明符] <转换操作符>
      
      - *0个或多个标志字符*
      
        - \-   左对齐
        - \+  正数前加+
        - 空格  正数前加空格  
        - \#        
        - 0    前导0填充（若有左对齐无效，且受精度说明限制）
      
      - **最小宽度说明** 数字
      
        - 数字  字符宽度最小值，如果小于就增加前导空格，大于自动增大，**不会截断**
      
        - \*     
      
          ```c
          printf("%*d\n", 2, PAGES);     printf("%2d\n",PAGES);
          ```
      
          
      
      - **精度说明** .数字 一般用于浮点数小数位数
      
        - 数字
        - *
      
      - *长度修正说明符*  
      
      - **转换操作符**（必选）
      
        - 格式转换说明符输出**类型 数量** 一定要与后面的参数类型相匹配
      
        ​        如果不匹配，**结果是未定义的（难以预料）**
      
        - ​           **- %d : int**
      
          ​           \- %ld : long
      
          ​           **- %u : unsigned int**
      
          ​           \- %lu : unsigned long
      
          ​           \- %x %X : 整型的十六进制形式(0x1f)
      
          ​           \- %o : 整型的八进制形式(017)
      
          ​           **- %c : char**
      
          ​           **- %f :float / double** 
      
          ​           **\- %lf : long double**
      
          ​           \- %e : 以科学计数法形式输出
      
          ​           \- %s : 字符串 
      
          ​           \- %p : 指针地址
          
        - 在 stdio.h 中定义了sizeof返回的类型为底层类型size_t ( 有利于移植 )
        
          ```c
          printf("%zd,%zd",sizeof(char),sizeof(int));
          ```
        
          
    
2. scanf格式化输入函数

    - 一般形式  scanf（字符串字面值，参数1，参数2 …… 参数n）；

    - scanf在匹配输入格式时，是匹配不到 \n ，scanf中**不要去写 \n**

    - scanf在匹配格式时自动跳过空格、换行、制表符

    - **scanf()**执行后会返回一个整数值，表示成功**读取到几个值**

    - **double** **： printf中用 %f**

    ​                              **scanf中用 %lf**

    - 易错点 ： 

      ```c
      scanf("请输入：%d");  //二次输入
      ```

      

3. scanf()函数接收输入数据时，遇以下情况结束**一个数据**的输入：（不是结束该scanf函数，scanf函数**仅在每一个数据域均有数据**，并按**回车**后结束）。
    - **遇到空白**（空格或"回车"，或"跳格"），例子：scantf（"%d%d",&a,&b）如果这样输入：12空格23，当对a输入时，录入了12，然后遇到空格，满足条件，停止对a录入，所以a的值为12
    - **按指定宽度结束**，例如"%3d"，只取前3列
    - **遇到非法输入时**。例如：scantf("%c%f",&b,&c) 若这样输入：a 123o.26 本例子中，b得到a,对c输入本该是1230.26，但是把0错打成了o(字母 欧)，遇到o属于非法输入，结束对c的录入，所以c得值为123 

4. ![输入流](D:\常用文件\软件工程\C\img\输入流.png)

#### 2.3.2getchar和putchar

- ​    \- putchar 字符输出函数/ getchar字符输入函数

           putchar() 在命令行输出**一个字符**
    
    ​       getchar() 在命令行读取**一个字符**(在输入是**不会忽略任何字符** 如：换行)
    
    ```c
    #include <stdio.h>
    int main()
    {
    　　char a,b;
        
    　　a=getchar();
    　　b=getchar();
    　　putchar(a);
    　　putchar(b);
        
       return 0;
    }
    ```

#### 2.3.3gets和puts   

- **如果想要完整的读取一行内容（包含空格），可以使用gets()**

- puts()在完成**字符串**打印之后，**自动打印一个换行**。

  如果只是原原本本的输出某个字符串，使用puts()

##第三章 运算符   

### 3.1 概念

1. 由多个或单个操作数、运算符组成的符合C语言规则的式子叫做表达式。

2. 左值 ： 可以进行写入（赋值）操作的一块内存，如： 变量

   右值 ： 可以进行读取操作的一块内存 ， 如： 变量，常量，字面值。

### 3.2 算数运算符

1. 四则运算

    - 结果为右值
    
    - 除法 /
    
      - **一个整数除以浮点数结果为浮点数 **
    
      - **两个整数相除，结果为整数（取整）**
    
      - 除数不能为0 ，**会报错。**
      - Pyhton与C语言对于负数整除的处理是不一样的
                Python:        -3 // 2   =>   -2
                 C     :              -3 / 2    =>   -1
          原因是因为**Python向负无穷取整、C向0取整**

2. 取余%
    - C语言中取余运算的结果 = 两个操作数**绝对值进行取余**，**符号与左操作数相同**（开发中少用负数取余）
    - 同样右操作数不能为0，**会报错。**
    - 对小数取余**会报错**
    
3. 自增运算符

    - **前自增**运算符 （前++） ++操作数
      先对操作数进行+1操作，再参与**表达式**运算。
    - **后自增**运算符 （后++） 操作数++
      先参与**表达式**运算，在对操作数进行+1操作。
    - 在实际开发中，不允许在**一个表达式**中对**一个变量**多次进行
      自增、自减操作

4. 自减运算符

###3.3赋值运算符
1. 赋值运算符 ：=

   - **不是判断是否相等**

   - 语法形式：  操作数1 = 操作数2 

   - 把操作数2的值赋值给操作数1

   - 操作数1必须是可被修改的左值
     \- 二元运算符，从右到左，**优先级倒数第二低**
      **-** **运算结果为右值**


​     

2. 复合赋值运算符
   - 算术复合赋值运算符：+=、-=、*=、/=、%= 
         \- += ：二元运算符，从右到左
           int a = 10;  a += 10;  // a=20
           在变量a本身的基础上 +10，并把结果赋值给a
             a += 10  <==>  a = a + 10
   - 位复合赋值运算符：&= |= ~= <<= >>= ^=

### 3.4 关系运算符

1. **在运算时：0：表示假  非0：表示真**

   **在结果中： 0：表示假   1： 表示真 **

   如果关系表达式成立，结果为1，不成立，结果为0

2. **从左到右**

3. 易错点

    ```c
int a = 200;   0 <= a <= 100  // 结果恒定为1
    ```

### 3.5 逻辑运算符

1. 判断真假，&&，||，!

2. 短路问题

   与： 左操作数为假，则不继续运算

   或： 左操作数为真，则不继续运算

   用途：

    ```c
while (++cnt <= 5 && (c=getchar())!=EOF)
{
...
}//当cnt > 5 时， 不再进行输入 
    ```

### 3.6 条件运算符

- 形式 操作数1 ？操作数2 ：操作数3

  操作数1为真，执行2，否则执行3
  
- **易错点**

  ```c
  a = 1;
  b = 2;
  a + b <= 1 ? a++: b++,a++;  //  , 前面为条件运算
  ```
  
- 应用场景

  ```c
  printf( a>=0&&a<=100 ? "合法\n" : "不合法\n");
  ```

  

### 3.7 位运算符

1. 对内存中每一位进行运算
2. 按位与 & ，按位或 | **按位非 ~**
3. **位异或  ^ 相同为0，不相同为1.**
4. 左移(<<) 和右移(>>)
    - 左移时无论是有符号数还是无符号数总是移位和补零，即总是逻辑左移。
    - 左移1位相当于原数乘以2。（适用于无符号数和一部分有符号数）
    - 右移时无符号数是移位和补零，为逻辑右移；而有符号数为算术右移，即在最高位整数补0，负数补1。
    - 右移时无符号正数和有符号数可以达到除2的效果。
    - 移位33次会变为移位1次。

### 3.8 逗号运算符

- **优先级最低**的运算符，二元运算符，从左到右

### 3.9 括号运算符

- 改变优先级

### 3.10 sizeof运算符

- 求数据或者是类型所占内存字节数，（*输出是用转换说明符%zd* 一般不用）。
- 易错点： 在求字符串长度时求的是字符串的字符个数，要加上字符结尾的**空字符**
##第四章 语句

###4.1. 流程图符号

   ![流程图](D:\常用文件\软件工程\C\img\流程图.png)

###4.2. 顺序结构

- 从上到下依次执行每一条语句

###4.3. 表达式语句

   - 表达式语句 = 表达式 + 分号
   - 表达式是 操作数加运算符 组成的符合**C语言语法**的式子
   - 常见的表达式语句
     - 赋值语句
     - 自增语句
     - 函数调用语句

###4.4. 复合语句

   - 复合语句就是**大括号**及其中*0个或多个声明或语句**共同构成
   - 复合语句可以认为是一条语句

###4.5. return 语句

   - return；
   - return 表达式
   - return语句表示结束当前函数执行。

###4.6. 分支语句

####4.6.1 if 语句

- 形式： if   或  if……else  或者  if……else if……else if……
  
- if 在一个if语句中只允许出现一次，else if 任意次  ， else  0 次或一次。
  
- 实例：四则运算（让用户输入的时候，要检查其是否输入了相应个数的数据）
  
         #include <stdio.h>
         
         int main(void)
         {
         	int a, b, flag;
         	char opt;
         
         	printf("请输入一个式子\n");
         	flag = scanf ("%d %c %d",&a,&opt,&b); //返回成功输入的读取到3个值
         	                                      //注意输入 3 21 1 时读取到的是 3 2 1
     

####4.6.2 swi**t**ch
- 多路分支语句 ， 也叫作开关语句
  
- 形式
  
       ```c
       switch (表达式)
       {
           case 整型字面值1:
               语句1;
               break;
           case 整型字面值2:
               语句2;
               break;
           case 整型字面值3:
               语句3;
               break;
           ...
           default
               语句 n;
       }
       ```
   
- 实例：评等级
  
  ```c
  #include <stdio.h>
  
  int main (void)
  {
  	int n;
  
  	scanf("%d",&n);
  
      switch(n / 10){        // n / 10
  	    case 1:            //用冒号
  	    case 2:
  	    case 3:
  	    case 4:
  	    case 5:
  			puts("差");
  		    break;
  	    case 6:
  	    case 7:
  	    case 8:
  		    puts("中");
  			break;
  	    case 9:
  	     	puts("优");
  	}
  	return 0;
  }
  ```
  
  
  
  - 如果表达式的值等于switch语句中某个case标号中的整型字面值（每个case标号中的字面值**不能相同**），则程序会控制跳转到相应case标号执行，并且逐行执行，一直到**switch语句执行结束**，或**遇到break**为止。
  - 如果表达式的值不等于任何case标号后面的字面值，则**跳转到default分支**执行。如果switch中没有default分支，则不执行任何分支，跳转到switch后面的语句执行。
  
  
  
- 如果分支后面没有break语句，**则继续往下执行**
  
-  case标号后面字面值只能是整型字面值（**包括字符字面值**）

### 4.7 循环语句

#### 4.7.1 for循环

- 基本形式： for （初始表达式； 条件表达式 ；循环表达式） 
  - 三种表达式都可以没有，**条件表达式为空表示恒成立**
  
  - C语言中，**不允许在初始化表达式中定义变量**，但是C++、Java时允许的。
  
  - 常用在**循环次数已知**，需要**迭代变量**时
  
  - 注意边界问题
  
  - 实例
  
    - 猜数字（随机函数）
  
      ```c
      #inlcude <stdlib.h> // C语言标准库头文件，包含rand()函数
      #include <time.h>   // C语言时间库头文件，包含time()函数
      
      int main(void) 
      {
          srand(time(0));// 把当前程序运行的时刻作为随机数种子
          a = rand() % 10 + 1;        // 可以产生一个随机数 范围[1,10]
          return 0;
      }
      ```
  
    - 打印int二进制（有三种位运算的方式）
  
      - 二进制末位是1是奇数，末位是0是偶数
  
      - 1与1相与结果为1, 0与1相与结果为0
  
      - 符号位为1，小于0，符号位为0，则大于或等于0。 （n << i）< 0
  
        判断为真返回1，判断为假返回0.

#### 4.7.2 while循环

- 基本形式 while（条件表达式）

- 又叫当型循环，表示当条件满足时执行循环

- 不允许不写条件表达式，死循环写法while（1）

- 当循环次数未知时使用

- 实例

  买苹果 （while循环要注意到循环体中等差和等比数列，最好代入数值检验一遍）

  相似题型 求圆周率
  
  ```c
	int apple = 2, day = 1;         //数列的首项
  	double money = 0.0;				//累加器初始化 字面值 小数 0.0
  
  	while (apple <= 100){          //停止的条件（检验）
  		money += apple * 0.8;      //累加器
  		day++;                     //等差数列
  		apple *= 2;                //等比数列
  	}
  ```
  
  

#### 4.7.3 do……while循环

- 基本形式

  ```c
  do
  {
  	// 循环体    
  } while (循环条件) ;
  ```

  - {  } 不能省略；以分号结束

- 和for while循环的根本区别，循环体至少执行一次。

- 实例：解一元二次方程

  开平方sqrt（）; 

  清缓存区fflush  

  清屏在 windows.h> 中 system() 函数表示在命令行输入， cls表示清屏

  当用户输入完成，程序给出结果之后，**询问是否再次输入**。

#### 4.7.4 多重循环

- 打印三角形（for循环嵌套for循环）

- 打印菱形（for循环嵌套for循环）（找出两个迭代变量之间的关系）（找三组数据再找规律）

  从0递增后递减回0

  ```c
  -0	0   0  
  -1	1	1
  -2	2	2
  -3	3	3
  -4	4	2	-4 + 6
  -5	5	1	-5 + 6
  -6	6	0   -6 + 6
  ```

- 十以内加减法自测小程序（do……while嵌套for循环）

###4.8 中断语句

#### 4.8.1 break语句

- 在switch语句中

​       跳出switch语句，结束当前switch语句的执行。

-  在循环语句中

​       跳出当前循环，执行循环后的语句，表示结束循环执行的意思。

-  break**会跳出离它最近的switch**语句或循环语句。
-  *相当于跳到条件表达式处并返回1*

#### 4.8.2 continue语句

- **只允许出现在循环语句中**
- 表示结束**本次**循环，执行下次循环
- *相当于跳到条件表达式处并返回1*

#### 4.8.3 goto语句

- 建议**不要在实际开发中使用goto语句**，会使程序代码**结构变得异常混乱**。

- 示例：打印1-100

- ```c
  #include <stdio.h>
  
   int main(void)
   {  
     int i = 1;
   label1:
     printf("%d\n", i);
     i++;
     if (i == 101)
       goto label2;
     goto label1;
   label2:
  
     return 0;
   }
  ```
##第五章 数组

### 5.1 数组的概念

####5.1.1 数组的定义

- 数组是类型相同的数据元素的集合

  - 类型包括构造类型

  - 各个数据元素只能顺序的排列在内存中

- 格式 
  - 类型 数组名 [ 数组大小 ]
    - 数组大小只能是字面值或者字面值的表达式
    - C语言编译器在**编译期间**就要确定数组类型**所占内存的大小**
    - 数组大小只能是**正整数**

#### 5.1.2 数组的使用

- 如定义一个数组 int arr[ 6 ], 相当于定义了六个 int 类型的变量，

  这六个变量的名称分别为 arr[ 1 ]、arr[ 2 ]、arr[ 3 ]、arr[ 4 ]、arr[ 5 ]、arr[ 6 ]

- 访问数组： 数组名 [ 下标 ]

  下标**从零开始**

### 5.2 一维数组

#### 5.2.1 一维数组的初始化

- 定义： 在**定义变量的同时**进行赋值

#####    方法一 ： 全部初始化

- int arr[5] = {1, 2, 3, 4, 5};
- 右侧的列表称为 **初始化列表**

#####   方法二： 部分元素赋初值

- int arr [ 5 ] = { 1, 2, 3}  

- 如果发现数组中仍有元素没有被初始化，则默认初始化为0
- 实际开发中，通常采用部分元素赋初值的方法对数组元素进行初始化，例如：**int arr[100] = {0};** 

#####  方法三： 省略长度赋初值

-  int a[] = {1, 2, 3, 4, 5};  **// 不要省略中括号 [ ]**
- 数组大小即 初始化列表 元素的个数

#### 5.2.2  一维数组的实例

- 求平均值、最大值、最小值、数组逆置 ( 遍历数组 ) 

- 数组排序（**重点**）
  - 选择排序
  
    ```c
    	for(i = 0; i < n - 1; i++){
    		min = i;
    		for(j = i + 1; j < n; j++){      //i,j分别代表有序区和无序区的最后一个和第一个
    			if (arr[min] > arr[j])
    				min = j;
    		}
    		temp = arr[min];			  
    		arr[i] = arr[min];
    		arr[min] = temp;
    	}
    ```
  
    
  
  - 冒泡排序
  
    ```c
    	printf("请输入要进行排列的数据\n");
    
    	for(i = 0; i < n; i++){                 //输入数组,n = 10
    		scanf("%d",&arr[i]);				//ij分别代表第几次和一行中的第几个。
    	}
    
    	for (i = 0; i < n - 1; i++){            // n - 1
    		for(j = 0; j < n - 1 - i; j++){     // n - 1 - i
    			if (arr[j] > arr [j+1]){
    				temp = arr[j];
    				arr[j] = arr [j + 1];
    				arr[j + 1] = temp;
    			}
    		}
    	}
    
    	for(i = 0; i < n; i++){					 //打印数组
    		printf("%d ",arr[i]);                //注意空格
    	}
    ```
  
  - 直接插入排序
  
    ```c
    	int i, j, n = 7;					//i,j分别代表有序区和无序区的最后一个和第一个
    	int temp;
    	int arr[] = {10, 11, 12, 14, 9, 5, 4};
    
    	//从小到大排列
    	for(i = 1; i < n; i++){
    		temp = arr[i];
    		for(j = i; j > 0 && arr[j - 1] > temp; j--){    //关键 数组中移动一个数  边界值
    			arr[j] = arr[j - 1]; 
    		}
    		arr[j] = temp;
    	}
    
    ```
  
    <img src="D:\常用文件\软件工程\C\img\IMG_20200701_174252.jpg" alt="IMG_20200701_174252" style="zoom:15%;" />
  
    
  
- 数组最大值与末尾元素交换

- 实例：模拟双色球（避免重复）

  ```c
  for(i = 0; i < 6; i++){
  	redArr[i] = rand() % 6 + 1;
  	for(j = 0; j < i; j++){
  		if (redArr[j] == redArr[i]){        //避免重复
  			i--;
  			break;
  		}
  	}
  }
  ```
  

### 5.3 二维数组

#### 5.3.1 二维数组与一维数组

- 二维数组相当于存放一维数组的一维数组

#### 5.3.2 二维数组的定义

- 格式： 类型名  数组名\[ 行数 ][列数]

  | int arr\[3][4] | 第0列 | 第1列 | 第2列 | 第3列 |
  | -------------- | ----- | ----- | ----- | ----- |
  | 第0行          | 1     | 2     | 3     | 4     |
  | 第1行          | 5     | 6     | 7     | 8     |
  | 第2行          | 9     | 10    | 11    | 12    |

####5.3.3 二维数组的初始化

##### 方法一：全部初始化

##### 方法二： 部分初始化

- 按行部分赋值

``` c
int arr[2][3] = {{1, 2}, {4}};
```

| int arr\[2][3] | 第0列 | 第1列 | 第2列 |
| -------------- | ----- | ----- | ----- |
| 第0行          | 1     | 2     | 0     |
| 第1行          | 4     | 0     | 0     |

- 顺序部分赋值（**注意顺序**）

``` c
int arr[2][3] = {1, 2, 3, 4};
```

| int arr\[2][3] | 第0列 | 第1列 | 第2列 |
| -------------- | ----- | ----- | ----- |
| 第0行          | 1     | 2     | 3     |
| 第1行          | 4     | 0     | 0     |

##### 方法三： 省略长度初始化

- **可0以省率行数，不能省率列数**

- 按行

``` c

int brr[][3] = {{1,2}, {3, 4}}; // int brr[2][3]
```

| int brr\[][3] | 第0列 | 第1列 | 第2列 |
| ------------- | ----- | ----- | ----- |
| 第0行         | 1     | 2     | 0     |
| 第1行         | 3     | 4     | 0     |

- 按顺序

``` c
int arr[][3] = {1, 2, 3, 4, 5}; // int arr[2][3]
```

| int arr\[][3] | 第0列 | 第1列 | 第2列 |
| ------------- | ----- | ----- | ----- |
| 第0行         | 1     | 2     | 3     |
| 第1行         | 4     | 5     | 0     |

####5.3.4 二维数组的实例

- 二维数组遍历

- 求平均成绩（**很容易出错**）

  ```c
  #include <stdio.h>
  
  int main(void)
  {
  	int arr[3][4] = {0};
  	int i, j;
  	double aveStudent[4], aveSubject[3];   //平均值数据类型一般是小数，一般输出是保留两位小数
  
  	for(i = 0; i < 3; i++){                //输入二维数组，注意行列的标号均从0开始
  		printf("请依次输入四位同学的");       //格式化输出字符串
  		switch(i){
  			case 0: printf("外语 ");break; //从0开始
  			case 1: printf("高数 ");break;
  			case 2: printf("C语言");break;
  		}
  		printf("成绩（输入完后按回车）：");
  		for(j = 0; j < 4; j++){
  			scanf("%d", &arr[i][j]);    //取地址符
  		}
  	}
  
     	for(i = 0; i < 3; i++){				//按行读取数据
  		int sum = 0;					//在局部声明
  		for(j = 0; j < 4; j++){
  			sum += arr[i][j];
  		}
  		aveSubject[i] = sum / 4.0;
  	}
      
  	for(j = 0; j < 4; j++){             //按列读取数据
  		int sum = 0;					
  		for(i = 0; i < 3; i++){
  			sum += arr[i][j];
  		}
  		aveStudent[j] = sum / 3.0;
  	}
  ```

- 矩阵

  - 以找变量之间的**规律**为主（类似于多重循环的几个实例）

  - 矩阵对角线元素之和

    - 矩阵两条**对角线交叉处**不要重复

    - 写程序时矩阵元素的**角标是从0 开始**

    - 对角线元素特点 **i == j, i + j == 阶数 - 1**

      ```c
          for (i=0; i<5; i++) {				//输入的同时进行求和，简化了程序
              for (j=0; j<5; j++) {
                  scanf("%d", &num);
                  if (i==j || i+j==4) {
                      sum += num;
                  }
              }
          }
      ```

  - 外圈元素之和

    ```c
     (i==0 || j==0 || i==4 || j==4)
    ```

  - 蛇形填数

###5.4 字符数组

####5.4.1 字符数组和字符串

- 字符数组的最后一个字符为\0时就是字符串，不是\0为普通的字符数组，字符串可以使用对字符串类型的操作

#### 5.4.2 字符串的保存

- ```c
  char s1[6] = {'a', 'b', 'c', 'd', 'e', '\0'};
  char s2[6] = "abcde";
  // s1 与 s2 初始化的效果是相同的
  ```

- 易错点

  必须保证能存下** ‘\0’** ；

  单引号；

#### 5.4.3 字符串的打印和保存

- ```c
  char str[100];
  scanf("%s", str); 
  printf("%s\n", str);
  ```

  注意：scanf读取字符串使用%s，另外数组名前面不需要加 & 。

  字符串在打印的时候，实际上是打印的第一个'\0'之前所有的字符。

  ```c
  char str[100];
  //输入 ni hao a
  scanf("%s", str); 
  //打印 ni
  printf("%s\n", str);
  ```

  scanf在读取字符串时，**遇到空格会任务字符串输入截止**，不会读取空格及空格之后的内容。

  **scanf不会读取空格**。

- ```c
  char str[100];
  gets(str); 
  puts(str);
  ```

  puts()在完成字符串打印之后，自动打印一个换行。

  如果预期读取的字符串中包含空格，使用gets()

  如果只是原原本本的输出某个字符串，使用puts()

#### 5.4.4 字符串的四种基本操作的实现（重要代码）

- ```c
  	// 求字符串长度
    	char str[] = "asdfaasdf";	
    	int i;
    	for(i = 0; str[i]; i++);	//遍历字符串 且i最后表示的是字符长度
    	printf("%d",i);
    	// 字符串拷贝
    	char str1[] = "asdfaasdf";	  
    	char str2[50];
    	int i;
    	for(i = 0; str2[i]; i++)	
    		str2[i] = str1[i];
    	str2[i] = '/0'; 
    	// 字符串拼接
    	char str1[50] = "asdf";	    //注意此时空余位置都是 0
    	char str2[] = "aasdf";
    	int i, j;
    	for(i = 0; str1[i]; i++);
    	for(j = 0; str2[j]; j++)
    		str1[i + j] = str2[j]; //不用再加上末位的 0 ， 因为初始化的方式为部分初始化，未定义的元								   素自动为 0 ！;
    	
      // 字符串比较大小  相等打印0， 大于打印1， 小于打印-1
      // "abcd"  相等  "abcd"    
      // "aaaa"  小于  "abcd"
      // "cd"    大于  "abcd"
      // "abcd"  大于  "abc"
      char str1[] = "abcd";
      char str2[] = "abcd";
      int i, rtn;
    
    	for(i = 0; str1[i] == str2[i] && str2[i]!= 0; i++);  //易错  不要写成 str1[i] ==  																str2[i]!= 0！！
    	
    	rtn = str1[i] - str2[i];
    
      if (rtn > 0)
          rtn = 1;
      else if(rtn < 0)
          rtn = -1;
      printf("%d\n", rtn);
  ```
#### 5.4.5 字符串的函数

- strlen() ：求字符串长度

- strcmp() ： 字符串比较

- strcpy() ：字符串拷贝

  实例： 密码验证

- strcat() ： 字符串拼接

## 第六章  指针

### 6.1 什么是指针

- 指针就是储存地址的变量

### 6.2 定义指针

- ```c
  int * p = &num
  ```

  - 可称为 p 指向num
  - 该指针类型为整型指针

### 6.3 指针的使用和运算

- & ： 取地址符，获取一个变量的地址, 地址仅仅是一个**数值**
- \* ： 寻址符，通过一个指针（地址）找到它所对应的**内存空间**
- **%p**:  格式化输出时类型转换说明符为 %p（地址类型的） 
- ==、!=、>、< ： 关系运算符
- 指针 +（ - ） 整数： 移动指针位置

- 指针 - 指针
  - 指针- 指针 求的是两个指针地址之间，单位元素的个数（单位就是指针指向的变量的类型）

  - **不存在 指针 + 指针 运算**！

### 6.4 指针的存储

- 32位机，指针占用4个字节内存空间
- 64位机，指针占用8个字节内存空间
- 但是通常开发环境中无论32位机还是64位机，指针**都占4个字节**
- 区分概念
  - p 的类型为指针占用4个字节的内存空间
  - p 指向的类型为整型，p + 1 表示向后移动一个 int 单位长度
  - &num 的类型是指针（地址），**type = int ***

### 6.5 指针的初始化

- 没有进行初始化的指针称为**野指针**，指向哪是**不确定**的
- 对于指针初始化可以赋值为某个变量的地址
- 如果指针在定义时指向哪不确定，需要在程序运行过程中进行赋值，那么它的**初始值可以赋值为 NULL**，称这种指针为**空指针**

> ​		NULL和0的值都是一样的，但是为了目的和用途及容易识别的原因，NULL用于指针和对象，0用于数值对于字符串的结尾，使用'\0'，它的值也是0，但是让人一看就知道这是字符串的结尾，不是指针，也不是普通的数值
> ​		在不同的系统中，NULL并非总是和0等同，NULL仅仅代表空值，也就是指向一个不被使用的地址，在大多数系统中，都将0作为不被使用的地址，所以就有了类似这样的定义但并非总是如此，也有些系统不将0地址作为NULL，所以说，千万别将NULL和0等价起来，特别是在一些跨平台的代码中

### 6.6 多重指针

- 若一个指针存储的内容是另一个指针的地址，则称这个指针为多重指针。

- 定义：声明说明符 * 类型限定符列表 * 类型限定福列表 

- 注意：

  - 允许连续**寻址**   ( **p )
  - 在使用中，一定要注意多重指针的等价表示形式

  ```c
      printf("&p1 = %p\n", &p1);      // p1的地址
      printf("p2 = %p\n", p2);        // p1的地址
  ```

### 6.7 指针与一维数组（难点）

- 当一个指针指向数组某元素时，可以通过这个指针加减来访问数组中的每一个元素

- 下标访问元素 本质上就是 指针加减寻址  **arr[i] => *(arr+i)**

- 数组名，可以理解成它是一个特殊的指针，类似于指针而又跟指针有区别( **重要** )

  - arr在数值层面 它表示的就是 arr数组**首元素**的地址（指针）**&arr[0] =>  &*(arr+0) => arr+0 => arr**
  - arr在变量层面 它表示的就是 一个长度为5元素类型为int的**数组**

  ```c
      int i; 
      int arr[5] = {11, 22, 33, 44, 55};
      int * p = &arr[0];
  
      for (i=0; i<5; i++) {
          //可以交换
          printf("%d[arr] = %d\n", i, i[arr]);
          printf("arr[%d] = %d\n", i, arr[i]);
          //可以替换
          printf("*(arr+%d) = %d\n", i, *(arr+i));
          printf("*(p+%d) = %d\n", i, *(p+i));
          printf("arr[%d] = %d\n", i, arr[i]);
          printf("p[%d] = %d\n", i, p[i]);
      }
  
  	// 不同点！！！！！！！！！！！！！
      printf("%p\n", arr);    // 数组首元素（arr[0]）的地址
      printf("%p\n", p);      // 数组首元素（arr[0]）的地址
      printf("%p\n", &arr);   // 整个数组（int arr[5]）的地址
      printf("%p\n", &p);     // 指针变量p的地址
  
      printf("arr  + 1 = %p\n", arr + 1);  // 移动一个int单位！！！！
      printf("&arr + 1 = %p\n", &arr + 1); // 移动一个数组（int [5]）单位！！！！！
  									     // arr 的类型是 int*， &arr 的类型是 int * [5]！
  
      printf("sizeof(arr) = %d\n", sizeof(arr));  // 20 求的是整个数组（int arr[5]）的大小
      printf("sizeof(p) = %d\n", sizeof(p));      // 4  求的是指针变量p的内存大小
  ```

- 数组指针和指针数组

  优先级：()>[]>*
  
  ```c
  //数组指针
  定义 int (*p)[n];
  ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
  
  如要将二维数组赋给一指针，应这样赋值：
  int a[3][4];
  int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
   p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
   p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
  
  所以数组指针也称指向一维数组的指针，亦称行指针。
  ```
  
  ```c
  //指针数组
  定义 int *p[n];
  []优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
  如要将二维数组赋给一指针数组:
  int *p[3];
  int a[3][4];
  for(i=0;i<3;i++){
      p[i]=a[i]
      p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
  }
  
  这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
  所以要分别赋值。
  ```
  
  ​		这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
  
  ​		还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
  比如要表示数组中i行j列一个元素：\*(p[i]+j)、\*(\*(p+i)+j)、(*(p+i))[j]、p\[i][j]
  
- 练习

  ```C
  已知： int a[3][4] ={{1,3,5,7}, {9,11,13,15}, {17,19,21,23}};
  int(*p)[4] = a;
  int*q = &a[0][0] 请用 p,q 分别表示下面的表达式：
      
  a[1]		a[1] = *(a + 1) = 9的地址   p + 1					q + 4
  a+2 		a + 2 = 第三行的地址         p + 2				  q + 8
  a[2][ 2]	a = 21					   *(*(p + 2) + 2))		  *(q + 10)
  ```

### 6.8 指针与字符串（难点）

- 字符串数组、字符串指针和字符串字面值

  - 字符串字面值：是一个指针，指向该字符串在只读区中存放该字符数组的首元素

  - 表示方式

    ```c
    //数组形式字符串
    char arr[] = "ABCD";   //arr是字符串数组，在栈区的内存中保存着'A', 'B', 'C', 'D', '\0'
    //指针形式字符串                  
    char * p = "ABCD";     //p 是字符串指针， 数据“ABCD”保存在只读区中， 同时“ABCD”表示只读区中						   的字符数组的首地址， 而p保存的是这个首地址。
                             
    ```

  - 赋值方式

    ```c
    //数组形式字符串
    //正确形式
    	//定义时赋初值
    	char arr[] = "ABCD";
    	//用用格式化输入函数字符串函数
    	char arr[10];
    	scanf("%s", str); 
    	strcpy(arr,"ABCD");
    //错误形式
    	//定义后赋值
    	char arr[10];
    	arr = "ABCD"
    ```

    ```c
    //指针形式字符串  
    	//定义时赋初值
    	char * p = "ABCD";
    	//定义后赋值
    	char *p;
    	*p = "ABCD"
        //动态规划内存
        char *p = NULL;
    	p = (char *)malloc(10);
        scanf("%s", p);
    	strcpy(p,"ABCD");
    ```

  - 修改

    - 字符串数组可以字符串内容，但是不能修改字符串地址

      改变字符串内容后地址保持不变

    - 字符串指针可以修改字符串地址但是不能修改字符串内容

    ```c
    char *p = "hello"; //字符指针指向字符串常量
    *p = 'a'; 		   //错误，常量不能被修改，即指针变量指向的字符串内容不能被修改
    
    char *p = "hello"; 			//字符指针指向字符串常量
    char ch = 'a';
    p = &ch; 					//指针变量指向可以改变
    ```

  - 字符串函数的传入值

    ```c
    //不用修改原字符串
    strcmp(); // 两个参数必须都能读
    strlen(); // 参数必须能读
    //需要修改原字符串
    strcat(); // 参数1必须能写（不能是字符串字面值），参数2必须能读
    strcpy(); // 参数1必须能写（不能是字符串字面值），参数2必须能读
    ```

- 字符指针数组

  - **区别于字符串数组**，字符指针数组的元素类型才是字符串
  - 实例：字符指针数组保存字符串排序

###6.9 几种特殊的指针

- const 指针

  - 在指针赋值的时候，只允许加限制，不允许减限制（丢常操作）

    ```c
    const int num = 10;
    // 丢常，在赋值的过程中丢失了const的限制，会报错
    int * p = &num; // const int *  ->  int *
    *p = 100;
    ```

  - 常量指针 指针常量 常量常指针

    ```c
    #include <stdio.h>
    
    int main(void)
    {   
        int num = 10;
        // 常量指针，指向常量的指针
        const int * p1 = &num; 	//*p1 不能被修改
        int const * p2 = &num;	//*p2 不能被修改
        // 指针常量，指针本身是常量
        int * const p3 = &num;  //p3 不能被修改
        // 常量常指针
        int const * const p4 = &num;  // 指针p4 和 p4指向的位置均不能被修改
    
        return 0;
    }
    ```

- void * 指针 
  - void* 指针：不携带类型信息的指针，**只保存地址编号**，不知道所指向内存的数据类型。
  - void * 指针**不允许进行寻址**。
  - 任意类型的指针都可以**赋值**给 void * 指针，void * 指针想要赋值给其他类型指针，需要进行**显示类型转换**。

### 6.10 指针与二维数组

- 操作

  ```c
      // 1、解释二维数组名寻址之后表示的含义
      //     *arr是什么？
      //     *arr表示：第一个长度为4的int一维数组的首元素的地址（11的地址）
      // 2、解释二维数组名寻址之后再寻址所表示的含义
      //     **arr是什么？
      //     **arr表示：第一个长度为4的int一维数组的首元素（11）
      // 3、寻址法 和 下标法 访问元素，下标访问元素本质上就是寻址
  
      int arr[3][4];
  
      printf("%d\n", **arr);         printf("%d\n", arr[0][0]);
      // arr[0][0] =>  *(arr[0]+0)  => *(*(arr+0)+0) => **arr
      printf("%d\n", *(*arr+1));     printf("%d\n", arr[0][1]);
      // arr[0][1] =>  *(arr[0]+1)  => *(*(arr+0)+1) => *(*arr+1)
      printf("%d\n", **(arr+1));     printf("%d\n", arr[1][0]);
      // arr[1][0] => *(*(arr+1)+0) => **(arr+1)
      printf("%d\n", *(*(arr+2)+2)); printf("%d\n", arr[2][2]);
      // arr[2][2] => *(*(arr+2)+2)
  ```

- 练习

  ```c
  已知：int a[2][3];下列各表达式的含义：
  &a       : 二维数组的地址
  a        : 第一行的地址
      
  &a[0]    : &*(a) = a  第一行的地址
  a[0]	 : *(a) = *a  第一行第一个元素的地址
  方法： 转换成寻址    
  
  a[0][0]  : 第一行的第一个元素
  &a[0][0] : 第一行的第一个元素的地址
  ```

  ```c
  已知：int a[3][4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};
  则：
  a[1]+2       :     13的地址
  *(a+1)+2     :     13的地址
  *(a[1]+2)    : 	   13
  *(*(a+1)+2)  :     13
  (*(a+1))[2]  :     13
  以上表达上表示什么？
  ```


## 第七章 函数

### 7.1 什么是函数

- 函数是能够完成**特定功能**的代码集合。
- 函数的**作用**：
  - 减少程序的代码量，减少代码冗余
  - 提升代码的复用性
  - 改善程序代码的逻辑结构

### 7.2 函数的定义

- 函数定义的语法
  ```c
  返回值类型 函数名（形参列表）{
      函数体
  }
  ```

- 返回值类型：当函数执行完成后后，需要返回的数据的类型，当函数给出返回值类型后，必须在函数体中返回相应类型的数据。

  - 当函数不需要返回数据时，返回值类型应该写void
  - 当返回值类型为void时，函数体**可以不写return语句**
  - 返回值不能是局部变量的地址（地址处的内容已将没有了）

- 形参列表：在调用函数时，需要传递给函数的数据，表示函数正常执行所需要的数据。
  - void fun() : 表示接受**任意多**的实参，只不过函数体执行时不会去使用这些实参。
  - void fun(void) : 表示**不接受**任何参数，如果在函数调用语句中传递实参了，那么编译器会**报错**。

### 7.3 函数的调用和执行

- 基本概念： 主调函数 、被调函数、实参、形参

- 内存中功能区的划分

  | 区域   | 功能                                                         |
  | ------ | ------------------------------------------------------------ |
  | 代码区 | 存放函数被编译后的二进制可执行代码                           |
  | 数据区 | **只读区**:存放常量, 如:常量字符串,const修饰的全局变量等； **可读写区**:存放全局变量和静态变量 |
  | 栈     | 存放函数运行时所需的参数,寄存器环境,返回值,局部变量          |
  | 堆     | 除去其他三个区域,剩下的都是堆,不连续                         |

- 步骤（重要）

  1. 保存现场：记住执行到多少行
  2. 为形参分配内存空间
  3. 将实参拷贝到形式参数中
  4. CPU从主调函数转到被调函数中
  5. 若有返回值，就将返回值保存到一个固定位置
  6. 释放用于本次函数调用为被调函数开辟的内存空间
  7. CPU利用记录下的行数，返回到主调函数

### 7.4 传地址

- 在被调函数中**修改主调函数中的变量值**时，可以通过**传递**主调函数变量的**地址**来实现。
- 在实际开发中，可以通过传地址来达到返回多个返回值的效果。
- 无论是传值还是传地址，本质上都是实参往形参的值赋值过程。（函数调用的第三步，这里传递即拷贝）

### 7.5 数组作为参数

- C语言中，数组**无法直接赋值**

- C语言中，如需要在函数调用时传递数组，那么通常传递数组**首元素地址**和**数组长度**，来实现传递数组的效果

- 在函数定义时，形参列表如果需要传递数组，可以将数组**首元素地址定义成类似于数组**的形式，例如 int p[]，但是这只是一种表现形式，本质上还是 int * p。

  ```c
  // 实现函数printArr， 功能是打印数组每一个元素
  void printArr (int * p, int len) 
  {
      int i;
      for (i=0; i<len; i++) 
          printf("%d\n", *(p+i));
  }
  ```

### 7.6 递归函数（难点）

- 递归就是函数调用过程中直接或间接的**调用函数自身**

- 思路

  - 数学根据是**归纳法**（以第一归纳法为例）

    第一步：归纳奠基

    第二步：归纳假设

    第三步：归纳递推

- 原则

  - 基准原则：必须有一个确定的**基准情况**
  - 不断推进： 对于需要递归求解的情况，使用递归调用必须**朝着产生基准情况的方向走**
  - 设计原则： **假设所有的递归调用都可以实现**（不必思考复杂的细节，把细节交给计算机）
  - 合成效益法则：极力避免在**不同的**递归调用中做**重复性**的工作。

- 实例
  - 阶乘
  - 斐波那契数列
  - 汉诺塔问题

### 7.7 字符串函数相关的实现

```c
int strlen(const char * s)                           
int strcmp(const char * s1, const char * s2) 		 
char * strcpy(char * s1, const char * s2)			//s1必须是可修改的值，定义字符串时要注意
char * strcat(char * s1, const char * s2) 			//s1必须是可修改的值，定义字符串时要注意
```

**注意**：都有返回值！！！！！！！

### 7.8 生存周期和作用域

- 作用域：就是变量能够使用的范围

  - 变量定义完成后，仅能在**当前代码段**或**更低级别代码段**使用。
  - 允许在**不同代码段**中定义**相同名称**的变量。

- 生存周期（生命周期）

  - 一个变量从分配内存到释放内存的过程
  - 动态生存周期：根据代码的执行过程，变量创建及变量的释放都是根据**代码执行过程**来确定。
  - 静态生存周期：变量的创建是在**程序执行开始**就创建的，在**程序执行结束**后再销毁。变量在整个程序执行期间都存在。
    - 静态生存周期变量的初始化：如果静态生存周期的变量在定义时没有指定初值，会**默认初始化为0**。
    - 全局变量：在全局范围内定义的变量，生存周期为静态生存周期，并且在当前源文件内**任意位置**都可以访问。
      - 作用范围是**当前整个源文件**，**当前源文件**任意位置都可以访问全局变量。
    - 局部变量，在代码当中定义的变量，作用返回仅限于当前代码段及子代码段。
      - 一般的局部变量
      - 静态局部变量：在局部变量定义时前面加上`static`（**作用域是局部的，生存周期是整个源程序**）

  - 静态生存周期与动态生存周期的区别：
    1. 动态生存周期变量**随代码执行创建和销毁**，静态生存周期变量在程序执行期间**一直存在**。
    2. 动态生存周期变量不初始化值为**随机值**，静态生存周期变量不初始化**默认初始化为0**。
    3. 动态生存周期变量存储的内存区域为**栈区**，静态生存周期的变量存储的内存区域为**静态全局区**。

### 7.9 动态内存分配标准库函数

- ```c
  // 向系统申请size大小内存，返回申请到的内存首地址
  // 申请失败返回NULL。
  void * malloc (unsigned int size);
  
  // 向系统申请 size*count 大小的内存，返回申请到的内存首地址
  // 申请失败返回NULL。
  void * calloc (unsigned int count, unsigned int size);
  
  // 将申请到的内存归还给系统
  void free(void * p);
  ```

  申请的内存位于**堆区**

  malloc 函数不会对申请到的内存做任何初始化操作。

  calloc 函数会将申请到的内存初始化为0。

  free 函数会将你之前申请到的内存归还给系统。

- 实例 排序

  ```c
  #include <stdio.h>
  #include <malloc.h>
  
  int main(void)
  {
  	int i, j, n, temp;
      //1.定义指针
  	int * p = NULL;
  
  	scanf("%d",&n);						
  	//2.申请内存
  	p = (int*) malloc(n * sizeof(int));	
  
  	for(i = 0; i < n; i++){
  		scanf("%d",p + i);				//移动指针表示地址
  	}
  
  	for(i = 1; i < n; i++){									//直接插入排序
  		temp = p[i];
  		for(j = i - 1; j > 0 && p[j] > temp; j--){
  			p[j + 1] = p[j];
  		}
  		p[j + 1] = temp;
  	}
  	
  	for(i = 0; i < n; i++){
  		printf("%d\n",p[i]);			//用下标的方式表示元素
  	}放内存
  	free(p);
  
  	return 0;
  }
  ```

## 第八章 自定义数据类型

###8.1 结构体（struct）

#### 8.1.1 定义结构体

- ```c
  struct 结构体标识符
  {
      类型1 结构体成员1;
      类型2 结构体成员2;
      .... 
  };                      //不用忘记最后的分号！！！！！！！
  ```

- `struct` 是结构体的**关键字**

- `student` 是表示**结构体类型**的标识符

- `struct student` 是定义的**新的结构体类型名称**

- C语言结构体成员中

  - 不允许出现**静态生存周期**的成员；
  - 不允许结构体中出现当前结构体类型的成员（递归定义），因为编译器无法确定结构体内存大小。
  - 不允许出现**当前结构体别名的指针**，因为定义结构体类型时别名还未起作用。

#### 8.1.2 结构体的使用

- 定义结构体变量

  - 结构体的同时定义结构体变量

  ```c
  struct Text{
      ……
  }op1,op2;
  或
  struct{
      ……
  }op1,op2;
  ```

  - 定义结构体后定义结构体变量

    - 利用`typedef`进行简化

    ```c
    typedef struct Text{
        ……
    }text，*ptext;   	//同时定义结构体的指针
    ```

- 赋值

  - 定义结构体变量的时候对成员整体赋初值

    ```c
    text a = {…………};  //按定义时的顺序
    ```

  - 定义后单独赋值

  - **同类型**结构体变量可以互相赋值（**不涉及到指针成员**）

- 访问成员

  - 结构体变量. 成员名
  - 结构体指针. 成员名

- 结构体变量，可以作为函数的形式参数和返回值类型

- 结构体数组

#### 8.1.3 内存对齐方式

- https://www.bilibili.com/video/BV1Ja4y1i7AF?from=search&seid=5198907397854726353

- 因为CPU读取数据时是以一个固定的字节数为一个单位进行并行读取的的，所以为了尽可能的提高寻址效率，有了内存的对齐方式

- 对齐的原则是

  - 每种类型的对齐值就是它的对齐边界

  - 要求**数据存储地址**和**数据所占内存大小**是对齐值的倍数
  - 对齐边界取数据类型大小和平台最大对齐边界中较小的一个
    - 平台最大对齐边界在32位机上是4字节，在64位机上是8字节（一般会使用4个字节）

- 对于结构体而言步骤如下

  1. 取到对齐值

  2. 找到一个符合要求的结构体起始位置

  3. 一次为每一个成员寻找符合要求的起始地址间隔出来的字节用空字节填充

  4. 用空字节填充在结构体的尾部使结构体的大小是对齐值的整倍数（便于数组寻址）

	<img src="/img/内存分配.png" style = "zoom : 75%;">

### 8.2 联合体 （union）

- 又叫做共用体或联合

- 联合体所有成员**共同使用一块内存**

- 与结构体的区别

  - 联合体在定义变量时只能对**第一个值**进行赋初值的操作
  - 联合体**最后接受修改**的是起作用的成员
  - 联合体成员占用的空间是各个成员中最大的

- 在结构体定义时可以定义联合体，在联合体定义时也可以定义结构体

- 用法示例

  ```c
  #include <stdio.h>
  
  union test
  {
      char a;
      int b;
  };
  
  int main(void) 
  {
      union test t1;
      t1.a = 'A';
      t1.b = 10000;
      printf("%c\n", t1.a);	//此时t1.a的值会截取10000的后1个字节
      printf("%d\n", t1.b);
  
      t1.a = 'B';
      printf("%c\n", t1.a);
      printf("%d\n", t1.b);  //在定义t1.a = 'B' 只是覆盖了一个字节
  
      return 0;
  }
  ```

### 8.3 枚举 (enum)

- 枚举：将可能的取值一一列举出来。

- 枚举变量的值只能是列举出来的值中的一个。

- 定义

  ```c
        enum  枚举类型名 { 有限集合元素列表 };
  例如： enum weekday {sun, mon, tues, wednes, thurs, fri, satur};
  例如： enum sex {boy, girl};
  ```

- 枚举类型在定义时，大括号中给出的是所有取值可能，并且用`逗号`隔开

- 枚举类型可以增加程序的**可读性和安全性**

- 枚举在内存中保存的实际上就是一个**正整数**

- 枚举的成员都是**常量**

- 与switch结合

  ```c
  #include <stdio.h>
  
  enum week{Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
  
  int main(void)
  {
      scanf("%d", &day);
      
      switch(day){
        case Mon: puts("Monday"); break;
        case Tues: puts("Tuesday"); break;
        case Wed: puts("Wednesday"); break;
        case Thurs: puts("Thursday"); break;
        case Fri: puts("Friday"); break;
        case Sat: puts("Saturday"); break;
        case Sun: puts("Sunday"); break;
        default: puts("Error!");
      }
      return 0;
  }
  ```

- 序号用户不定义是则从0开始，想要查看序号需使用**强制类型转换**

### 8.4 链表（难点）

- 顺序存储（数组）在数据操作时的缺陷。
  - 扩容不方便
  - 数据的插入和删除操作代价过高

- 链表的基本操作

  ```c
  #include <stdio.h>
  #include <malloc.h>
  
  typedef struct node
  {
      int data;
      struct node * next;
  } Node, * List;
  
  // typedef   struct node       Node;
  // typedef   struct node *     List;
  
  // 1. 在链表末尾添加节点
  // List * 会因为要在当前函数修改main函数中的list的值
  // List * pList <==>  struct node ** pList
  void pushBackList(List * pList, int data)
  {
      Node * temp = *pList;
      Node * newNode = (Node *) malloc(sizeof(Node));
      newNode->next = NULL;
      newNode->data = data;
  
      if (temp == NULL) {
          // 空链表
          *pList = newNode;
      }
      else {
          // 非空链表，有有效节点
          // 遍历链表，找到最后一个节点（尾节点的next等于NULL）
          while (temp->next != NULL)
              temp = temp->next;
          temp->next = newNode;
      }
  }
  
  
  // 2. 打印链表所有节点
  void printList(List list) 
  {
      Node * temp = list;
      for (; temp!=NULL; temp=temp->next)
          printf("%d\n", temp->data);
      puts("===================");
  }
  
  // 3. 求链表节点个数
  int sizeList(List list) 
  {
      int size = 0;
      Node * temp = list;
      for (; temp!=NULL; temp=temp->next)
          size++;
      return size;
  }
  
  // 4. 释放链表
  void freeList(List * pList) 
  {
      Node * temp = *pList;
      Node * del = NULL;
      while (temp != NULL) {
          del = temp;
          temp = temp->next;
          free(del);
      }
  }
  
  // 5. 根据指定数据删除匹配节点
  void deleteList(List * pList, int data) 
  {
      Node * temp = *pList;
      Node * del = NULL;
      while (temp->next != NULL) {
          if (temp->next->data != data) {
              temp = temp->next;
              continue;
          }
          // temp->next->data == data
          del = temp->next;
          temp->next = del->next;
          free(del);
      }
  
      // 判断首节点是否要删除
      temp = *pList;
      if (temp->data == data) {
          *pList = temp->next;
          free(temp);
      }
  }
  
  // 6. 在指定位置插入节点  return 0 表示插入失败 1 表示成功
  int insertList(List * pList, int index, int data) 
  {
      Node * temp = *pList;
      Node * newNode = NULL;
      int size = sizeList(temp);
      int i;
      
      // 判断插入位置是否合法 
      if (index < 0 || index > size)
          return 0;
  
      // 创建新节点
      newNode = (Node *) malloc (sizeof(Node));
      newNode->data = data;
      newNode->next = NULL;
  
      // 如果在首节点之前插入节点
      if (index == 0) {
          newNode->next = temp;
          *pList = newNode;
          return 1;
      }
  
      // 在非首节点之前插入节点，寻找插入位置的前一个节点
      for (i=1; i<index; i++)
          temp = temp->next;
  
      newNode->next = temp->next;
      temp->next = newNode;
      return 1;
  }
  
  int main(void)
  {
      // 创建一个空链表
      List list = NULL; // struct node * list = NULL;
      pushBackList(&list, 33);
      pushBackList(&list, 11);
      pushBackList(&list, 22);
      pushBackList(&list, 33);
      pushBackList(&list, 44);
      pushBackList(&list, 55);
      pushBackList(&list, 33);
      pushBackList(&list, 66);
      pushBackList(&list, 33);
      printf("size = %d\n", sizeList(list));
      printList(list);
  
      deleteList(&list, 33);
      printf("size = %d\n", sizeList(list));
      printList(list);
  
      insertList(&list, 5, 100);
      insertList(&list, 2, 200);
      insertList(&list, 0, 300);
      printf("size = %d\n", sizeList(list));
      printList(list);
  
      freeList(&list);
  
  	return 0;
  }
  ```

  